#!/usr/bin/env python3
"""Generate an easy-to-read current network status report."""

from __future__ import annotations

import argparse
import json
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List

ROOT_DIR = Path(__file__).resolve().parent.parent
if str(ROOT_DIR) not in sys.path:
    sys.path.insert(0, str(ROOT_DIR))

from decentralized_ai_network_demo import (
    DEFAULT_LAUNCH_STATE_PATH,
    IdentityRegistry,
    TranslationNetwork,
    UnstoppableLaunchSentinel,
    load_env_file,
    run_qa_team_suite,
    to_jsonable,
)

PROTOCOL_NAME = "Distributed Proof-of-Useful-Inference Network"
PROTOCOL_ID = "dpuin-protocol"


def _safe_decimal_str(value: Any) -> str:
    return str(value)


def _top_node_balances(snapshot: Dict[str, Any], limit: int = 5) -> List[tuple[str, Any]]:
    balances = snapshot.get("balances", {})
    node_items = [(k, v) for k, v in balances.items() if k.startswith("node-")]
    node_items.sort(key=lambda kv: float(kv[1]), reverse=True)
    return node_items[:limit]


def build_status_payload(production_checks: bool, launch_state_path: str) -> Dict[str, Any]:
    identities = IdentityRegistry.from_env()
    network = TranslationNetwork()
    checks = network.run_preflight_checks(security_scan_passed=True, production_mode=production_checks)
    network.open_mainnet()

    outputs = []
    for envelope in network.build_demo_requests():
        outputs.append(network.process_request(envelope))

    snapshot = to_jsonable(network.state_snapshot())

    sentinel = UnstoppableLaunchSentinel(
        state_path=launch_state_path,
        owner_id=identities.owner_id,
    )
    launch_state = sentinel.snapshot()

    qa = run_qa_team_suite(production_mode=production_checks)
    avg_latency = 0.0
    if outputs:
        avg_latency = sum(float(item["winner_latency_ms"]) for item in outputs) / len(outputs)

    payload = {
        "generated_at_utc": datetime.now(timezone.utc).isoformat(),
        "mode": "network-status-agent",
        "protocol_name": PROTOCOL_NAME,
        "protocol_id": PROTOCOL_ID,
        "production_checks": production_checks,
        "network_size_nodes": len(network.nodes),
        "avg_winner_latency_ms": round(avg_latency, 2),
        "preflight_checks": checks,
        "qa_overall_passed": qa["overall_passed"],
        "qa_agent_count": len(qa["agents"]),
        "launch_state": launch_state,
        "snapshot": snapshot,
        "top_node_balances": _top_node_balances(snapshot, limit=5),
    }
    return payload


def render_markdown(payload: Dict[str, Any]) -> str:
    snapshot = payload["snapshot"]
    launch_state = payload["launch_state"]
    top_nodes = payload["top_node_balances"]
    checks = payload["preflight_checks"]
    checks_lines = "\n".join(
        f"- `{k}`: `{v}`" for k, v in checks.items()
    )
    top_node_lines = "\n".join(
        f"- `{node}`: `{balance}`" for node, balance in top_nodes
    ) or "- none"

    return f"""# DPUIN Network Status

Generated at: `{payload['generated_at_utc']}`

## Summary

- Protocol: `{payload['protocol_name']}` (`{payload['protocol_id']}`)
- Network nodes: `{payload['network_size_nodes']}`
- QA overall: `{payload['qa_overall_passed']}` (`{payload['qa_agent_count']}` agents)
- Avg winner latency: `{payload['avg_winner_latency_ms']} ms`
- Production checks mode: `{payload['production_checks']}`

## Launch State

- Armed: `{launch_state.get('armed')}`
- Unstoppable started: `{launch_state.get('unstoppable_started')}`
- Successful open: `{launch_state.get('successful_open')}`
- Started by: `{launch_state.get('started_by_runner')}`
- Last runner: `{launch_state.get('last_runner_id')}`
- Total runs: `{launch_state.get('total_runs')}`
- Start attempts: `{launch_state.get('start_attempts')}`

## Preflight Checks

{checks_lines}

## Token Snapshot

- Epoch: `{snapshot.get('epoch')}`
- Model version: `{snapshot.get('model_version')}`
- Minted supply: `{snapshot.get('minted_supply')}`
- Max supply: `{snapshot.get('max_supply')}`
- Mainnet open: `{snapshot.get('mainnet_open')}`
- Account registry ready: `{snapshot.get('account_registry_ready')}`
- Connection configured: `{snapshot.get('connection_configured')}`

## Treasury Balances

- Founder treasury: `{snapshot['balances'].get('founder_treasury')}`
- Ecosystem treasury: `{snapshot['balances'].get('ecosystem_treasury')}`
- Security treasury: `{snapshot['balances'].get('security_treasury')}`
- Community treasury: `{snapshot['balances'].get('community_treasury')}`

## Top Node Balances

{top_node_lines}

---

This report is generated by `scripts/network_status_agent.py`.
"""


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Network status agent")
    parser.add_argument("--dotenv-path", default=".env")
    parser.add_argument("--production-checks", action="store_true")
    parser.add_argument("--launch-state-path", default=DEFAULT_LAUNCH_STATE_PATH)
    parser.add_argument("--output-md", default="docs/NETWORK_STATUS.md")
    parser.add_argument("--output-json", default="docs/NETWORK_STATUS.json")
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    load_env_file(args.dotenv_path)

    payload = build_status_payload(
        production_checks=args.production_checks,
        launch_state_path=args.launch_state_path,
    )
    markdown = render_markdown(payload)

    out_md = Path(args.output_md)
    out_json = Path(args.output_json)
    out_md.parent.mkdir(parents=True, exist_ok=True)
    out_json.parent.mkdir(parents=True, exist_ok=True)

    out_md.write_text(markdown, encoding="utf-8")
    out_json.write_text(json.dumps(to_jsonable(payload), ensure_ascii=False, indent=2), encoding="utf-8")

    print(json.dumps(to_jsonable(payload), ensure_ascii=False, indent=2))


if __name__ == "__main__":
    main()
